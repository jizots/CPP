#include "PmergeMe.hpp"
#include <iostream>

int	main(int ac, char** argv)
{
	try
	{
		PmergeMe data1(ac, argv);
	}
	catch(const std::exception& e)
	{
		std::cout << e.what() << '\n';
		return (1);
	}
	catch(const std::string& e)
	{
		std::cout << e << '\n';
		return (1);
	}
}


// Tool
//  https://jp.piliapp.com/random/number/ 乱数ジェネレーター
// Background knowledge
//  Jacobsthal number: J(0) = 0, J(1) = 1, J(n) = J(n-1) + (J(n-2) * 2) -> 0,1,1,3,5,11,21,43, J(8) = 85,…
// https://warwick.ac.uk/fac/sci/dcs/teaching/material-archive/cs341/fj.pdf

/* 1. initial 1~21 をランダムに配置*/
//  21 1 20 2 19 3 18 4 17 5 16 6 15 7 14 8 13 9 12 10 22

/* 2. make pair 横に並んでる数値でペアを作成*/
// 21 20 19 18 17 16 15 14 13 12 
//  1  2  3  4  5  6  7  8  9 10 22

/* 3. [compair] pair ペア間で大きい方の数値を比較して、片側（以下では上側）に寄せる*/
// 21 20 19 18 17 16 15 14 13 12
//  1  2  3  4  5  6  7  8  9 10 22

/* 4. ペアの大きい方の数値で、2と3を、要素が1つになるまで繰り返す*/
// ペアを作成して、大きい方の数値を上側へ（2回目）
// 21 19 17 15 13
// 20 18 16 14 12

// ペアを作成して、大きい方の数値を上側へ（3回目）
// 21 17
// 19 15 13

// ペアを作成して、大きい方の数値を上側へ（4回目）
// 21
// 17

// 21 繰り返し終了
// この時点で、私の期待ではベクター内は、8 14 7 15 6 16 5 17 4 18 3 19 2 20 1 21 10 12 9 13 22 となっている。

/* 5. ヤコブスタール数を用いて、並んでいない要素を2分挿入する*/
// この時、グループにするべき要素数より少ない場合は、少ないことを気にせずにグループにして良い。
// (2^(k+1) + (-1)^k) / 3 で、グループの中で最初に2分木挿入するインデックスを求めている。
// Befor: 8 14 7 [15] 6 16 5 [17] 4 18 3 19 2 20 1 [21] 10 12 9 13 22 , chunkScale: 8
// 15 17 21
//      [19 13]
// Befor: 10 12 9 [13] 8 14 7 [15] 6 16 5 [17] 4 18 3 19 2 20 1 [21] 22 , chunkScale: 8
// 13 15 17 21
//         [19   ]

// Befor: 10 [12] 9 [13] 8 14 7 [15] 6 16 5 [17] 4 18 3 [19] 2 20 1 [21] 22 , chunkScale: 4
// 12  13  15  17  19  21
//        [14  16][18  20]


//  10 12  13  14  15  16  17  18  19  20  21
//        [ 9   8][ 7   6][ 5   4   3   2   1  22]
// [9  8]グループの右側から2分探索して挿入します。
// この時、8のペアである10よりも小さい9以下の数値で、均等な2分木の場合のルートから2分探索します(in-order traversalでソートされた状態)
// つまりこの場合、揷入したい数値の8は最初に7と比較、次に9と比較して揷入位置の特定が完了します。

// なんで右側からなの？というと、たぶん、2分探索で比較する要素数が一定になるように、かな。例えば以下のように
//  3  4  5
//       [2  1]
// となっていた場合、2を先に挿入すると、比較する要素数が2つなので比較回数2回で　2 3 4 5になります。そして1を挿入すると、比較する要素数が4つなので比較回数3回で 1 2 3 4 5となります。合計5回の比較です。
// これを、1を先に挿入すると、比較する要素数が3つなので比較回数2回で　1 3 4 5になります。そして2を挿入すると、比較する要素数が3つなので比較回数2回で 1 2 3 4 5となります。合計4回の比較です。
// このように2分探索で比較する要素数が、挿入順によって変わらない（増加しない）ようにするために、いい感じのグループでくくっているのでしょう。

/*
n       =  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17
log(n!) =  0  1  3  5  7 10 13 16 19 22 26 29 33 37 41 45 49
B(n)    =  0  1  3  5  8 11 14 17 21 25 29 33 37 41 45 49 54
L(n)    =  0  1  3  5  9 11 14 17 25 27 30 33 38 41 45 49 65
*/

